#include "redblacktree.h"

namespace s21 {
    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::insert(const key_type &key, const mapped_value &value) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::insert(const key_type &key, const mapped_value &value) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::insert_or_assign(const key_type &key, const mapped_value &value) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    template <class InputIt>
    void RedBlackTree<Key, T, Compare, Allocator>::insert_range(InputIt first, InputIt last) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    std::pair<typename RedBlackTree<Key, T, Compare, Allocator>::iterator, bool> RedBlackTree<Key, T, Compare, Allocator>::emplace(const key_type& key, const mapped_value& value) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    typename RedBlackTree<Key, T, Compare, Allocator>::iterator RedBlackTree<Key, T, Compare, Allocator>::emplace_hint(const_iterator hint, const key_type& key, const mapped_value& value) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    std::pair<typename RedBlackTree<Key, T, Compare, Allocator>::iterator, bool> RedBlackTree<Key, T, Compare, Allocator>::try_emplace(const key_type& key, const mapped_value& value) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::erase(const key_type& key) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    std::optional<typename RedBlackTree<Key, T, Compare, Allocator>::value_type> RedBlackTree<Key, T, Compare, Allocator>::extract(const key_type& key) {

    }

    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::clear() {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::swap(RedBlackTree& other) {
        
    }

    template <class Key, class T, class Compare, class Allocator>
    void RedBlackTree<Key, T, Compare, Allocator>::merge(RedBlackTree& other) {
        
    }
}